{"meta":{"title":"童大侠的博客","subtitle":"大侠 🍤","description":"这是一段博客描述的字段......","author":"Ashton","url":"https://tongwp.com","root":"/"},"pages":[{"title":"介绍页","date":"2021-04-29T15:36:43.000Z","updated":"2021-05-07T10:15:21.192Z","comments":true,"path":"about/index.html","permalink":"https://tongwp.com/about/index.html","excerpt":"","text":"篩選出各種想法，將能夠做到的事化為行動後，大多數的事情都能夠具體實現。但這並不是終點而是起點。總之，先把事情完成，再來想想有什麽辦法能夠讓情況更完美，事情不是在【完成】那瞬間就結束，我們應該更執著於【怎樣做會更好】。而【篩選想法】就是掌握進步的關鍵。"},{"title":"分类页","date":"2021-04-29T07:34:28.000Z","updated":"2021-05-06T07:44:23.627Z","comments":false,"path":"categories/index.html","permalink":"https://tongwp.com/categories/index.html","excerpt":"","text":""},{"title":"标签页","date":"2021-04-29T07:31:08.000Z","updated":"2021-05-06T07:44:19.783Z","comments":true,"path":"tags/index.html","permalink":"https://tongwp.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"React Fiber","slug":"react-fiber","date":"2021-05-11T02:19:47.000Z","updated":"2021-05-11T02:24:15.202Z","comments":true,"path":"2021/05/11/react-fiber/","link":"","permalink":"https://tongwp.com/2021/05/11/react-fiber/","excerpt":"React现在的渲染都是由Fiber来调度 Fiber调度过程中的两个阶段(以Render为界) 产生原因 Fiber之前的reconciler（被称为 Stack reconciler ）自顶向下的递归mount/update，无法中断（持续占用主线程），这样主线程上的布局、动画等周期性任务以及交互响应就无法立即得到处理，影响体验 渲染过程中没有优先级 React Fiber的方式 把一个耗时长的任务分成很多小片，每一个小片的运行时间很短，虽然总时间依然很长，但是在每个小片执行完之后，都给其他任务一个执行的机会，这样唯一的线程就不会被独占，其他任务依然有运行的机会 React Fiber把更新过程碎片化，执行过程如下面的图所示，每执行完一段更新过程，就把控制权交还给React负责任务协调的模块，看看有没有其他紧急任务要做，如果没有就继续去更新，如果有紧急任务，那就去做紧急任务。","text":"React现在的渲染都是由Fiber来调度 Fiber调度过程中的两个阶段(以Render为界) 产生原因 Fiber之前的reconciler（被称为 Stack reconciler ）自顶向下的递归mount/update，无法中断（持续占用主线程），这样主线程上的布局、动画等周期性任务以及交互响应就无法立即得到处理，影响体验 渲染过程中没有优先级 React Fiber的方式 把一个耗时长的任务分成很多小片，每一个小片的运行时间很短，虽然总时间依然很长，但是在每个小片执行完之后，都给其他任务一个执行的机会，这样唯一的线程就不会被独占，其他任务依然有运行的机会 React Fiber把更新过程碎片化，执行过程如下面的图所示，每执行完一段更新过程，就把控制权交还给React负责任务协调的模块，看看有没有其他紧急任务要做，如果没有就继续去更新，如果有紧急任务，那就去做紧急任务。 维护每一个分片的数据结构，就是Fiber。 Fiber的调度过程分为以下两个阶段： render/reconciliation阶段 ===&gt; 里面的所有生命周期函数都可能被执行多次，所以尽量保证状态不变 componentWillMount componentWillReceiveProps shouldComponentUpdate componentWillUpdate Commit阶段 ===&gt; 不能被打断，只会执行一次 componentDidMount componentDidUpdate compoenntWillunmount 总结：新的Fiber 分片处理任务，当有紧急任务的时候，可以去优先处理紧急任务然后再回来调用","categories":[{"name":"Js笔记","slug":"Js笔记","permalink":"https://tongwp.com/categories/Js%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"react","slug":"react","permalink":"https://tongwp.com/tags/react/"}]},{"title":"类组件和函数组件的区别","slug":"react-class-fc","date":"2021-05-11T02:18:17.000Z","updated":"2021-05-11T02:24:21.840Z","comments":true,"path":"2021/05/11/react-class-fc/","link":"","permalink":"https://tongwp.com/2021/05/11/react-class-fc/","excerpt":"假设Greeting组件，它支持定义成类和函数两种性质。如果 Greeting 是一个函数，React 需要调用它。 123456// Greeting.jsfunction Greeting() &#123; return &lt;p&gt;Hello&lt;/p&gt;;&#125;// React 内部const result = Greeting(props); // &lt;p&gt;Hello&lt;/p&gt;","text":"假设Greeting组件，它支持定义成类和函数两种性质。如果 Greeting 是一个函数，React 需要调用它。 123456// Greeting.jsfunction Greeting() &#123; return &lt;p&gt;Hello&lt;/p&gt;;&#125;// React 内部const result = Greeting(props); // &lt;p&gt;Hello&lt;/p&gt; 如果 Greeting 是一个类，React 需要先将其实例化，再调用刚才生成实例的 render 方法 123456789// Greeting.jsclass Greeting extends React.Component &#123; render() &#123; return &lt;p&gt;Hello&lt;/p&gt;; &#125;&#125;// React 内部const instance = new Greeting(props); // Greeting &#123;&#125;const result = instance.render(); // &lt;p&gt;Hello&lt;/p&gt; React通过下面方式来判断组件的类型：123456// React 内部class Component &#123;&#125;Component.prototype.isReactComponent = &#123;&#125;;// 检查方式class Greeting extends React.Component &#123;&#125;console.log(Greeting.prototype.isReactComponent); // &#123;&#125;","categories":[{"name":"Js笔记","slug":"Js笔记","permalink":"https://tongwp.com/categories/Js%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"react","slug":"react","permalink":"https://tongwp.com/tags/react/"}]},{"title":"promise基础用法","slug":"promise","date":"2021-05-07T10:02:55.000Z","updated":"2021-05-07T10:21:53.511Z","comments":true,"path":"2021/05/07/promise/","link":"","permalink":"https://tongwp.com/2021/05/07/promise/","excerpt":"Promise 是异步编程的一种解决方案： 从语法上讲，promise是一个对象，从它可以获取异步操作的消息；从本意上讲，它是承诺，承诺它过一段时间会给你一个结果。 promise有三种状态：pending( 等待态 )，fulfiled( 成功态 )，rejected( 失败态 ) 状态一旦改变，就不会再变。创造promise实例后，它会立即执行。 promise是用来解决两个问题的： 回调地狱，代码难以维护， 常常第一个的函数的输出是第二个函数的输入这种现象 promise可以支持多个并发的请求，获取并发请求中的数据 promise可以解决异步的问题，本身不能说promise是异步的","text":"Promise 是异步编程的一种解决方案： 从语法上讲，promise是一个对象，从它可以获取异步操作的消息；从本意上讲，它是承诺，承诺它过一段时间会给你一个结果。 promise有三种状态：pending( 等待态 )，fulfiled( 成功态 )，rejected( 失败态 ) 状态一旦改变，就不会再变。创造promise实例后，它会立即执行。 promise是用来解决两个问题的： 回调地狱，代码难以维护， 常常第一个的函数的输出是第二个函数的输入这种现象 promise可以支持多个并发的请求，获取并发请求中的数据 promise可以解决异步的问题，本身不能说promise是异步的 Promise.prototype.then()和Promise.prototype.catch()resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去 reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。 一般来说，不要在then()方法里面定义 Reject 状态的回调函数（即then的第二个参数），总是使用catch方法。 12345678910111213// 不建议这么使用promise.then(function(data) &#123; // success&#125;, function(err) &#123; // error&#125;);// goodpromise.then(function(data) &#123; //cb // success&#125;).catch(function(err) &#123; // error&#125;); 第二种写法可以捕获前面then方法执行中的错误，也更接近同步的写法（try/catch）。 Promise.prototype.finally()finally()方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。 1234567promise.then(result =&gt; &#123; ...&#125;).catch(error =&gt; &#123; ...&#125;).finally(() =&gt; &#123; ...&#125;); 上面代码中，不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。finally方法的回调函数不接受任何参数，应该是与状态无关的，不依赖于 Promise 的执行结果。finally方法总是会返回原来的值。 Promise.all()Promise.all()方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。 12345const p = Promise.all([p1, p2, p3]);// p的状态由p1、p2、p3决定，分成两种情况。// 只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。// 只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。 Promise.all()方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。 Promise.race()Promise.race()方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。 12const p = Promise.race([p1, p2, p3]);// 上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。 Promise.race()方法的参数与Promise.all()方法一样，如果不是 Promise 实例，就会先调用下面讲到的Promise.resolve()方法，将参数转为 Promise 实例，再进一步处理。 Promise.allSettled()Promise.allSettled()方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只有等到所有这些参数实例都返回结果，不管是fulfilled还是rejected，包装实例才会结束。该方法由 ES2020 引入。 12345678const promises = [ fetch(&#x27;/api-1&#x27;), fetch(&#x27;/api-2&#x27;), fetch(&#x27;/api-3&#x27;),];await Promise.allSettled(promises);removeLoadingIndicator();//对服务器发出三个请求，等到三个请求都结束，不管请求成功还是失败，加载的滚动图标就会消失。 Promise.allSettled()的返回值allSettledPromise，状态只可能变成fulfilled。它的监听函数接收到的参数是数组results。该数组的每个成员都是一个对象，对应传入Promise.allSettled()的两个 Promise 实例。每个对象都有status属性，该属性的值只可能是字符串fulfilled或字符串rejected。fulfilled时，对象有value属性，rejected时有reason属性，对应两种状态的返回值。 1234567891011121314151617181920const resolved = Promise.resolve(42);const rejected = Promise.reject(-1);const allSettledPromise = Promise.allSettled([resolved, rejected]);allSettledPromise.then(function (results) &#123; console.log(results);&#125;);// [// &#123; status: &#x27;fulfilled&#x27;, value: 42 &#125;,// &#123; status: &#x27;rejected&#x27;, reason: -1 &#125;// ]//-------------------------------用法例子--------------------------------------const promises = [ fetch(&#x27;index.html&#x27;), fetch(&#x27;https://does-not-exist/&#x27;) ];const results = await Promise.allSettled(promises);// 过滤出成功的请求const successfulPromises = results.filter(p =&gt; p.status === &#x27;fulfilled&#x27;);// 过滤出失败的请求，并输出原因const errors = results .filter(p =&gt; p.status === &#x27;rejected&#x27;) .map(p =&gt; p.reason); 有时候，我们不关心异步操作的结果，只关心这些操作有没有结束。这时，Promise.allSettled()方法就很有用。如果没有这个方法，想要确保所有操作都结束，就很麻烦。Promise.all()方法无法做到这一点。 123456789const urls = [ /* ... */ ];const requests = urls.map(x =&gt; fetch(x));try &#123; await Promise.all(requests); console.log(&#x27;所有请求都成功。&#x27;);&#125; catch &#123; console.log(&#x27;至少一个请求失败，其他请求可能还没结束。&#x27;);&#125; Promise.any()ES2021 引入了Promise.any()方法。该方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例返回。只要参数实例有一个变成fulfilled状态，包装实例就会变成fulfilled状态；如果所有参数实例都变成rejected状态，包装实例就会变成rejected状态。","categories":[{"name":"Js笔记","slug":"Js笔记","permalink":"https://tongwp.com/categories/Js%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://tongwp.com/tags/javascript/"}]},{"title":"Type与Interface区别","slug":"type_interface","date":"2021-05-07T09:46:55.000Z","updated":"2021-05-07T10:02:08.340Z","comments":true,"path":"2021/05/07/type_interface/","link":"","permalink":"https://tongwp.com/2021/05/07/type_interface/","excerpt":"Type与Interface区别 可以在extend或Implements子句中命名接口，但是不能为对象类型文字提供类型别名。一个接口可以具有多个合并的声明，但是对象类型文字的类型别名不能。 type可以用于其它类型（联合类型、元组类型、基本类型[原始值]），interface不支持","text":"Type与Interface区别 可以在extend或Implements子句中命名接口，但是不能为对象类型文字提供类型别名。一个接口可以具有多个合并的声明，但是对象类型文字的类型别名不能。 type可以用于其它类型（联合类型、元组类型、基本类型[原始值]），interface不支持 Type不同点1234567891011type PartialPointX = &#123; x: number &#125;;type PartialPointY = &#123; y: number &#125;;// union(联合)type PartialPoint = PartialPointX | PartialPointY;// tuple(元祖)type Data = [PartialPointX, PartialPointY];// primitive(原始值)type Name = Number;// typeof的返回值let div = document.createElement(&#x27;div&#x27;);type B = typeof div; type能使用in关键字生成映射类型， 但interface不行 12345678type Keys = &#x27;firstname&#x27; | &#x27;surname&#x27;type DudeType = &#123; [key in Keys]: string&#125;const test: DudeType = &#123; firstname: &#x27;Lee sin&#x27;, surname: &#x27;jinx&#x27;&#125; Interface不同点interface可以多次定义，并被视为合并所有声明成员 type不支持 1234567interface Point &#123; x: number;&#125;interface Point &#123; y: number;&#125;const point: Point = &#123;x: 1, y: 2&#125;; 相同点 都可以描述一个对象或者函数 都可以进行拓展","categories":[{"name":"Js笔记","slug":"Js笔记","permalink":"https://tongwp.com/categories/Js%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://tongwp.com/tags/typescript/"}]}],"categories":[{"name":"Js笔记","slug":"Js笔记","permalink":"https://tongwp.com/categories/Js%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"react","slug":"react","permalink":"https://tongwp.com/tags/react/"},{"name":"javascript","slug":"javascript","permalink":"https://tongwp.com/tags/javascript/"},{"name":"typescript","slug":"typescript","permalink":"https://tongwp.com/tags/typescript/"}]}